{{! Import statements }}
from typing import List, Tuple, Any
from hexbytes import HexBytes
from cow_py.common.chains import Chain
from dataclasses import dataclass
from enum import Enum
from cow_py.codegen.components import BaseMixin, BaseContract, FileAbiLoader, ContractFactory, get_abi_file

{{! Generate data classes and enums }}
{{#each enums}}
{{#if @first}}
# TODO: Enums must be fixed before using them. They currently only use placeholder values.
{{/if}}
class {{this.name}}(Enum):
{{#each this.values}}
    {{this.name}} = {{this.value}}
{{/each}}

{{/each}}


{{#each dataClasses}}
@dataclass
class {{this.name}}:
{{#each this.properties}}
    {{this.name}}: {{this.type}}
{{/each}}

{{/each}}


class {{contractName}}Mixin(BaseMixin):
{{#each methods}}
    def {{this.name}}(self{{#each this.inputs}}{{#if @first}}, {{/if}}{{this.name}}: {{this.type}}{{#unless @last}}, {{/unless}}{{/each}}) -> {{this.outputType}}:
        return self.call_contract_method('{{this.originalName}}'{{#each this.inputs}}{{#if @first}}, {{/if}}{{#if this.isTuple}}{{this.destructuredArgs}}{{else}}{{this.name}}{{/if}}{{#unless @last}}, {{/unless}}{{/each}})
{{/each}}   


class {{contractName}}(BaseContract, {{contractName}}Mixin):
    def __init__(self, chain: Chain = Chain.MAINNET, address: str = ""):
        {{!-- TEMPORARY -- abiPath should be a resolved ABI given we're already generating this --}}
        abi_loader = FileAbiLoader(get_abi_file("{{contractName}}"))
        contract = ContractFactory.create('{{contractName}}', chain, address, abi_loader)
        super({{contractName}}, self).__init__(address, chain, abi=contract.ABI)
